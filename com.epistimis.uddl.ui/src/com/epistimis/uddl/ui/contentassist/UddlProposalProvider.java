/*
 * generated by Xtext 2.33.0
 */
/*
 * Copyright (c) 2022 - 2024 Epistimis LLC (http://www.epistimis.com).
 */
package com.epistimis.uddl.ui.contentassist;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScopeProvider;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;

import com.epistimis.uddl.CLRealizationProcessor;
import com.epistimis.uddl.ConceptualEntityProcessor;
import com.epistimis.uddl.LPRealizationProcessor;
import com.epistimis.uddl.LogicalEntityProcessor;
import com.epistimis.uddl.PlatformEntityProcessor;
import com.epistimis.uddl.UddlQNP;
import com.epistimis.uddl.uddl.ConceptualAssociation;
import com.epistimis.uddl.uddl.ConceptualComposition;
import com.epistimis.uddl.uddl.ConceptualParticipant;
import com.epistimis.uddl.uddl.LogicalComposition;
import com.epistimis.uddl.uddl.LogicalEntity;
import com.epistimis.uddl.uddl.LogicalParticipant;
import com.epistimis.uddl.uddl.PlatformComposition;
import com.epistimis.uddl.uddl.PlatformEntity;
import com.google.inject.Inject;

/**
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#content-assist
 * on how to customize the content assistant.
 */
public class UddlProposalProvider extends AbstractUddlProposalProvider {

	@Inject UddlQNP 					qnp;
	@Inject	IScopeProvider 				sp;
	
	@Inject ConceptualEntityProcessor 	ceProc;
	@Inject LogicalEntityProcessor 		leProc;
	@Inject PlatformEntityProcessor 	peProc;
	
	@Inject CLRealizationProcessor		clrproc;
	@Inject LPRealizationProcessor		lprproc;
	
	@Inject CLRealizationProposalProcessor clrpproc;
	@Inject LPRealizationProposalProcessor lprpproc;
	
	 
	protected <T extends EObject,U extends EObject> QualifiedName relativeQualifiedName(T obj, U ctx) {
		return qnp.relativeQualifiedName(obj, ctx);
	}


	/** Logical -> Conceptual */
	
	// TODO: Before enabling this code, we must change how these references are parsed. They should
	// be parsed to match the RIG
//	@Override
//	public void completeConceptualCharacteristicPathNode_ProjectedCharacteristic(EObject obj, Assignment assignment,
//			ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		EObject container = obj.eContainer();
//		// Start with the prior path node or, if this is the first one, the participant
//		// type as the anchor.
//		// list all the characteristic rolenames for the type
//		if (container instanceof ConceptualParticipant) {
//			// This is the first path node
//			ConceptualParticipant cp = (ConceptualParticipant) container;
//			ConceptualEntity type = cp.getType();
//			for (ConceptualComposition cc : getCCsFromSpecialization(type)) {
//				acceptor.accept(createCompletionProposal(qnp.relativeQualifiedName(cc, container).toString(),
//						cc.getRolename(), null, context));
//			}
//		}
//		if (container instanceof ConceptualParticipantPathNode) {
//			// This is not the first thing in the path - get context from the prior node
//			ConceptualParticipantPathNode cpn = (ConceptualParticipantPathNode) container;
//			ConceptualEntity type = cpn.getProjectedParticipant().getType();
//			for (ConceptualComposition cc : getCCsFromSpecialization(type)) {
//				acceptor.accept(createCompletionProposal(qnp.relativeQualifiedName(cc, container).toString(),
//						cc.getRolename(), null, context));
//			}
//		}
//		if (container instanceof ConceptualCharacteristicPathNode) {
//			// This is not the first thing in the path - get context from the prior node
//			ConceptualCharacteristicPathNode cpn = (ConceptualCharacteristicPathNode) container;
//			ConceptualCharacteristic cchar = cpn.getProjectedCharacteristic();
//
//			if (cchar instanceof ConceptualComposition) {
//				ConceptualComposableElement cce = ((ConceptualComposition) cchar).getType();
//				if (cce instanceof ConceptualEntity) {
//					ConceptualEntity ce = (ConceptualEntity) cce;
//					for (ConceptualComposition cc : getCCsFromSpecialization(ce)) {
//						acceptor.accept(createCompletionProposal(qnp.relativeQualifiedName(cc, container).toString(),
//								cc.getRolename(), null, context));
//					}
//				}
//				// NOTE: We ignore ConceptualObservables because there is no further path
//				// We include ConceptualAssociations because we may want to forward navigate
//				// through a participant (just like we do through a composition)
//				if (cce instanceof ConceptualAssociation) {
//					ConceptualAssociation ca = (ConceptualAssociation) cce;
//					for (ConceptualParticipant cc : ceProc.allParticipants(ca).values()) {
//						acceptor.accept(createCompletionProposal(qnp.relativeQualifiedName(cc, container).toString(),
//								cc.getRolename(), null, context));
//					}
//				}
//			}
//		}
//	}

	protected void processParticipant(ConceptualParticipant cp, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		ConceptualAssociation ca = (ConceptualAssociation)cp.eContainer();
		for (ConceptualParticipant cc: ceProc.allParticipants(ca).values()) {
			if (cc.getType().equals(cp.getType())) {
				acceptor.accept(createCompletionProposal(qnp.relativeQualifiedName(cc,cp).toString(),cc.getRolename(),null,context));					
			}
		}		
		
	}
//	/**
//	 * The set of choices for a projectedParticipant are all of the
//	 * assoc/participant combos where the participant type is the same as the
//	 * current entity. This is because we want to move from this entity back to
//	 * the assoc - so it has to be an assoc that could forward navigate to this
//	 * entity. We can only reverse navigate via participants, so we ignore compositions
//	 * that have this type. TODO: Is that right?
//	 */
//	@Override
//	public void completeConceptualParticipantPathNode_ProjectedParticipant(EObject obj, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		EObject container = obj.eContainer();
//		// Start with the prior path node or, if this is the first one, the participant type as the anchor.
//		// list all the characteristic rolenames for the type
//		if (container instanceof ConceptualParticipant) {
//			// This is the first path node - so go to the containing association and find all participants
//			// that match the type of this participant
//			ConceptualParticipant cp = (ConceptualParticipant)container;
//			processParticipant(cp,assignment,context, acceptor);
//		}
//		if (container instanceof ConceptualParticipantPathNode) {
//			// This is not the first thing in the path - get context from the prior node
//			ConceptualParticipantPathNode cpn = (ConceptualParticipantPathNode)container;
//			ConceptualEntity type = cpn.getProjectedParticipant().getType();
//			for (ConceptualParticipant cp: ceProc.allParticipants(type).values()) {
//				processParticipant(cp,assignment,context,acceptor);
//			}
//		}
//		if (container instanceof ConceptualCharacteristicPathNode) {
//			// This is not the first thing in the path - get context from the prior node
//			ConceptualCharacteristicPathNode cpn = (ConceptualCharacteristicPathNode)container;
//			ConceptualCharacteristic cchar  = cpn.getProjectedCharacteristic();
//			
//			if (cchar instanceof ConceptualComposition) {
//				ConceptualComposableElement cce  = ((ConceptualComposition)cchar).getType();
//				if (cce instanceof ConceptualAssociation) {
//					ConceptualAssociation ce = (ConceptualAssociation)cce;
//					for (ConceptualParticipant cp: ceProc.allParticipants(ce).values()) {
//						processParticipant(cp,assignment,context,acceptor);
//					}				
//				}
//				// NOTE: We ignore ConceptualObservables because there is no further path
//			}
//		}
//	}

	/**
	 * The only way to force calling a super class method is by calling from the derived class. So we create this callback to 
	 * be used by clrpproc to force the call to the super class method
	 * @param obj
	 * @param ruleCall
	 * @param context
	 * @param acceptor
	 */
	public void superComplete_LogicalComposition(EObject obj, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.complete_LogicalComposition(obj, ruleCall, context, acceptor);		
	}
	@Override
	public void complete_LogicalComposition(EObject obj, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		clrpproc.complete_Composition(this,clrproc, (LogicalEntity)obj, ruleCall, context, acceptor);		
	}

	/**
	 * The only way to force calling a super class method is by calling from the derived class. So we create this callback to 
	 * be used by clrpproc to force the call to the super class method
	 * @param obj
	 * @param ruleCall
	 * @param context
	 * @param acceptor
	 */
	public void superCompleteLogicalComposition_Rolename(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.completeLogicalComposition_Rolename(obj, assignment, context, acceptor);		
	}
	@Override
	public void completeLogicalComposition_Rolename(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		clrpproc.completeComposition_Rolename(this, clrproc, (LogicalEntity)obj, assignment, context, acceptor);
	}

	@Override
	public void completeLogicalComposition_Realizes(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		clrpproc.completeComposition_Realizes(this, clrproc, (LogicalEntity)obj, assignment, context, acceptor);
	}

	/** Platform -> Logical */
	/**
	 * The only way to force calling a super class method is by calling from the derived class. So we create this callback to 
	 * be used by clrpproc to force the call to the super class method
	 * @param obj
	 * @param ruleCall
	 * @param context
	 * @param acceptor
	 */
	public void superComplete_PlatformComposition(EObject obj, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.complete_PlatformComposition(obj, ruleCall, context, acceptor);		
	}
	@Override
	public void complete_PlatformComposition(EObject obj, RuleCall ruleCall, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		lprpproc.complete_Composition(this,lprproc, (PlatformEntity)obj, ruleCall, context, acceptor);

	}

	/**
	 * The only way to force calling a super class method is by calling from the derived class. So we create this callback to 
	 * be used by clrpproc to force the call to the super class method
	 * @param obj
	 * @param ruleCall
	 * @param context
	 * @param acceptor
	 */
	public void superCompletePlatformComposition_Rolename(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		super.completePlatformComposition_Rolename(obj, assignment, context, acceptor);		
	}
	@Override
	public void completePlatformComposition_Rolename(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		lprpproc.completeComposition_Rolename(this, lprproc, (PlatformEntity)obj, assignment, context, acceptor);
	}
		


	@Override
	public void completePlatformComposition_Realizes(EObject obj, Assignment assignment, ContentAssistContext context,
			ICompletionProposalAcceptor acceptor) {
		lprpproc.completeComposition_Realizes(this, lprproc, (PlatformEntity)obj, assignment, context, acceptor);

	}
}
