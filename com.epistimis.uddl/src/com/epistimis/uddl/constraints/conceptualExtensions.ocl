/**
 * UDDL Conceptual level - Epistimis extensions outside of the UDDL spec
 */
import ecore : 'http://www.eclipse.org/emf/2002/Ecore#/'

--import uddl : 'http://www.epistimis.com/uddl/Uddl'
--import  '../../../../../model/generated/Uddl.ecore'
import 'platform:/plugin/com.epistimis.uddl/model/generated/Uddl.ecore'


package uddl

	context UddlElement
	   /**
		 * Declare a helper operation to map an ok/warning verdict to ok/error.
		 */
		def: asError(verdict : Boolean) : Boolean = if verdict then true else null endif

	   /**
		 * Declare a helper operation to map an ok/warning verdict to ok/warning. This doesn't 
		 * do anything but gives us two functions with similar names in case developers forget
		 * they can just use they inv return 'as is' for warnings.
		 */
		def: asWarning(verdict : Boolean) : Boolean = if verdict then true else false endif


	context ConceptualComposableElement
	
		/**
		 * TODO: Nothing here addresses finding a data structure pattern in a general way. That would
		 * require knowing roles and contains/containment/ reference information. Roles are defined at the privacy
		 * level - so this problem will have to be addressed there.
		 */
		
		/**
		 * Return a set of all the model types referenced by this element
		 */
	    def: referencedModelTypes(): Set(ConceptualComposableElement) =
	 		if (self.oclIsKindOf(ConceptualObservable)) then
				self.oclAsType(ConceptualObservable).referencedModelTypes()
			else
				self.oclAsType(ConceptualEntity).referencedModelTypes()
			endif
	    	
		/**
		 * Does this element reference the specified type?
		 */
		def: referencesModelType(o:ConceptualObservable): Boolean = 
			self.referencedModelTypes()->includes(o)
			
		/**
		 * Does this element reference any of the specified observables?
		 */
		def: referencesAnyModelTypes(objs:Set(ConceptualObservable)): Boolean = 
			self.referencedModelTypes()->intersection(objs)->notEmpty()
	
		/**
		 * Does this element reference all of the specified observables?
		 */
		def: referencesAllModelTypes(objs:Set(ConceptualObservable)): Boolean = 
			let isect = self.referencedModelTypes()->intersection(objs) in
			isect->size() = objs->size()
	
			
	
	--	def: referencesModelType(o:ConceptualObservable): Boolean = 
	--		if (self.oclIsKindOf(ConceptualObservable)) then
	--			self.oclAsType(ConceptualObservable).referencesModelType(o)
	--		else
	--			self.oclAsType(ConceptualEntity).referencesModelType(o)
	--		endif
	
	
	context ConceptualObservable
		/**
		 * Return a set of all the model types referenced by this element
		 */
	    def: referencedModelTypes(): Set(ConceptualComposableElement) =
			self->asSet()
	
			
	--	def: referencesModelType(o:ConceptualObservable): Boolean = 
	--		self = o
	
	
	context ConceptualEntity
	
		static def: findByName(n: String): Set(ConceptualEntity) =
			ConceptualEntity.allInstances()->select(o|o.name = n)->asSet()
			
		/**
		 * Return a set of all the model types referenced by this element
		 */
		def: referencedModelTypes(): Set(ConceptualComposableElement) =
			let myComps = self.composition->collect(type.referencedModelTypes())->flatten()->asSet() in
			let parentTypes = if (self.specializes.oclIsUndefined()) then  Bag {} 
			else if self.specializes.oclIsKindOf(ConceptualAssociation) then
				self.specializes.oclAsType(ConceptualAssociation).referencedModelTypes() 
				else self.specializes.referencedModelTypes() 
				endif
			endif in
			-- Include 'self' because it is a structural type that we will sometimes want to know about
			self->asSet()->union(myComps->union(parentTypes))->asSet()
	
		def: matchingObservables(checklist: Set(uddl::ConceptualObservable) ): Set(uddl::ConceptualObservable) = 
			self.referencedModelTypes()->selectByType(uddl::ConceptualObservable)->select(t|checklist->includes(t)) 
			
	--	def: referencesModelType(o:ConceptualObservable): Boolean = 
	--		self.referencedModelTypes()->includes(o)
	
		/**
		 * oclIsKindOf uses the metamodel. We want to follow the UDDL
		 * specialization hierarchy
		 */		
		def: isTypeOrSpecializationOf(t: ConceptualEntity): Boolean =
			self = t or self.specializes.isTypeOrSpecializationOf(t)
		
	
	context ConceptualAssociation
	
		/**
		 * Return a set of all the model types referenced by this element
		 */
		def: referencedModelTypes(): Set(ConceptualComposableElement) =
			let compTypes = self.oclAsType(ConceptualEntity).referencedModelTypes() in
			-- This call will also handle the specialization 
			let assocTypes = self.participant->collect(type.referencedModelTypes())->flatten()->asSet() in
			compTypes->union(assocTypes)
	
	--	def: referencesModelType(o:ConceptualObservable): Boolean = 
	--		self.referencedModelTypes()->includes(o)
	
	 context ConceptualView
		/**
		 * Return a set of all the model types referenced by this element
		 */
		def: referencedModelTypes(): Set(ConceptualComposableElement) =
			if (self.oclIsTypeOf(ConceptualQuery)) then
				self.oclAsType(ConceptualQuery).referencedModelTypes()
			else 
				self.oclAsType(ConceptualCompositeQuery).referencedModelTypes()
			endif
	
	context ConceptualView
		def: matchingObservables(checklist: Set(uddl::ConceptualObservable) ): Set(uddl::ConceptualObservable) = 
			self.referencedModelTypes()->selectByType(uddl::ConceptualObservable)->select(t|checklist->includes(t)) 
	
	context ConceptualQuery
	
		/**
		 * Return a set of all the ConceptualEntities referenced by this element
		 * TODO: This requires a Java call - which isn't yet available.
		 * In the mean time, some simple string parsing might work in limited cases
		 * This only works on a single entity name - need to split it to get more
		 * Also does not work with aliases
		 */
	   def: referencedEntities(): Set(ConceptualEntity) =
	--		let names = name.tokenize(',') in
	--		let entities = LogicalEntity.allInstances()->select(o|names.includes(o.name))->asSet() in
			let lspec = self.specification.toLowerCase() in
			let fromNdx = lspec.indexOf(' from ') in
			let whereNdx = lspec.indexOf(' where ') in
			let joinNdx = lspec.indexOf(' join ') in
			let asNdx = lspec.indexOf(' as ') in
			let endNdx = if (asNdx > fromNdx) then
							asNdx
						 else if ( joinNdx > fromNdx) then 
								joinNdx 
						 	else if (whereNdx > fromNdx) then 
						 			whereNdx 
						 		else -- 
						 			self.specification.size() 
						 		endif
						 	endif
						 endif in
			let name = self.specification.substring(fromNdx+6,endNdx).trim() in
			 ConceptualEntity.allInstances()->select(o|o.name = name)->asSet()
	   
		/**
		 * Return a set of all the model types referenced by this element
		 */
		def: referencedModelTypes(): Set(ConceptualComposableElement) =
			self.referencedEntities()->collect(referencedModelTypes())->flatten()->asSet()
	
	
	
	context ConceptualCompositeQuery
		/**
		 * Return a set of all the model types referenced by this element
		 */
		def: referencedModelTypes(): Set(ConceptualComposableElement) =
			self.composition->collect(type.referencedModelTypes())->flatten()->asSet()


endpackage
