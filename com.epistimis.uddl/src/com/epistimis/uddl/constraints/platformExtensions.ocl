import '/resource/com.epistimis.uddl/model/generated/Uddl.ecore'
import 'conceptualExtensions.ocl'
import 'logicalExtensions.ocl'

package uddl

context PlatformComposableElement

	/**
	 * Return a set of all the model types referenced by this element
	 */
    def: referencedModelTypes(): Set(ConceptualComposableElement) =
 		if (self.oclIsKindOf(LogicalMeasurement)) then
			self.oclAsType(PlatformDataType).referencedModelTypes()
		else
			self.oclAsType(PlatformEntity).referencedModelTypes()
		endif
    	
	/**
	 * Does this element reference the specified type?
	 */
	def: referencesModelType(o:ConceptualObservable): Boolean = 
		self.referencedModelTypes()->includes(o)


context PlatformDataType
	/**
	 * Return a set of all the model types referenced by this element
	 */
    def: referencedModelTypes(): Set(ConceptualComposableElement) =
		self.realizes.oclAsType(LogicalComposableElement).referencedModelTypes()
		
		
context PlatformEntity

	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		let myComps = self.composition->collect(type.referencedModelTypes())->flatten()->asSet() in
		let parentTypes = if (self.specializes.oclIsUndefined()) then  Bag {} 
		else if self.specializes.oclIsKindOf(ConceptualAssociation) then
			self.specializes.oclAsType(PlatformAssociation).referencedModelTypes() 
			else self.specializes.referencedModelTypes() 
			endif
		endif in
		myComps->union(parentTypes)->asSet()
			
	/**
	 * oclIsKindOf uses the metamodel. We want to follow the UDDL
	 * specialization hierarchy
	 */		
	def: isTypeOrSpecializationOf(t: PlatformEntity): Boolean =
		self = t or self.specializes.isTypeOrSpecializationOf(t)


context PlatformAssociation

	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		let compTypes = self.oclAsType(PlatformEntity).referencedModelTypes() in
		-- This call will also handle the specialization 
		let assocTypes = self.participant->collect(type.referencedModelTypes())->flatten()->asSet() in
		compTypes->union(assocTypes)

context PlatformView
	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		if (self.oclIsTypeOf(PlatformQuery)) then
			self.oclAsType(PlatformQuery).referencedModelTypes()
		else 
			self.oclAsType(PlatformCompositeQuery).referencedModelTypes()
		endif

context PlatformQuery
	/**
	 * Return a set of all the model types referenced by this element
	 * TODO: This requires a Java call - which isn't yet available.
	 * In the mean time, some simple string parsing might work in limited cases
	 * This only works on a single entity name - need to split it to get more
	 * Also does not work with aliases
	 */
   def: referencedEntities(): Set(PlatformEntity) =
		let fromNdx = self.specification.toLowerCase().indexOf(' from ') in
		let whereNdx = self.specification.toLowerCase().indexOf(' where ') in
		let joinNdx = self.specification.toLowerCase().indexOf(' join ') in
		let endNdx = if ( joinNdx > 0) then 
						joinNdx 
					 else if (whereNdx > 0) then 
					 		whereNdx 
					 	else 
					 		self.specification->size() 
					 	endif
					 endif in
		let name = self.specification.substring(fromNdx+6,endNdx).trim() in
		PlatformEntity.allInstances()->select(o|o.name = name)->asSet() 

	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		self.referencedEntities()->collect(referencedModelTypes())->flatten()->asSet()


context PlatformCompositeQuery
	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		self.composition->collect(type.referencedModelTypes())->flatten()->asSet()

endpackage
