/**
 * 
 */
import ecore : 'http://www.eclipse.org/emf/2002/Ecore#/'
import  '../../../../../model/generated/Uddl.ecore'
include 'helpers.ocl'
include 'conceptual.ocl'
include 'conceptualExtensions.ocl'

/**
 * This contains more general capability for the EXTENSIONS at the logical level
 */

package uddl 

  context UddlElement
  
   /**
	 * Declare a helper operation to map an ok/warning verdict to ok/error.
	 */
	def: asError(verdict : Boolean) : Boolean = if verdict then true else null endif

 
   context LogicalEnumeratedBase
 	   /**
		 * Declare a helper operation to map an ok/warning verdict to ok/error.
		 */
		def: asError(verdict : Boolean) : Boolean = if verdict then true else null endif
 	
		 /**
		  * Find the root
		  */
		 def: root(): LogicalEnumerated =
	    	let container = self.oclAsType(ecore::EObject).eContainer().oclAsType(LogicalEnumeratedBase) in
	    	container.root()
	    	
 
     /*
     * Helper method that reroutes based on derived type
     */      
    def: flattenLabels(): Collection(LogicalEnumeratedBase) =
	     if self.oclIsTypeOf(LogicalEnumeratedSet) then
	        self.oclAsType(LogicalEnumeratedSet).flattenLabels()
	     else -- 
	        self.oclAsType(LogicalEnumerationLabel).flattenLabels()
	     endif 
         	
		/**
		 * All ProcessingBase classes can check containment using this method
		 * This determines if obj is contained in self's set labels (which includes self)
		 */
		def: contains(obj: LogicalEnumeratedBase): Boolean = 
			self.flattenLabels()->includes(obj)

 		def: contains(s: String): Boolean = 
			self.flattenLabels()->exists(l|l.name.toLowerCase() = s.toLowerCase())

		/**
		 * Is self contained in the passed in set (including any subelements)
		 */
		def: containedIn(s: Set(LogicalEnumeratedBase)): Boolean =
			s->collect(flattenLabels())->includes(self)
		/**
		 * Is self contained in the hierarchy of the passed in element?
		 */
		def: containedIn(s: LogicalEnumeratedBase): Boolean =
			s.flattenLabels()->includes(self)


		def: containedIn(s: String): Boolean =
			findSetRootedInName(s)->includes(self)

		def: containedIn(s: Set(String)): Boolean =
			s->collect(o|findSetRootedInName(o))->includes(self)


		/**
		 * Find a specific instance. Note that this looks through all of them. Use it sparingly
		 * NOTE: static methods are invoked using '::' instead of '.'
		 */	
		static def: findByName(n: String): LogicalEnumeratedBase =
			LogicalEnumeratedBase.allInstances()->select(o|o.name.toLowerCase() = n.toLowerCase())->asSequence()->first()

		/**
		 * Find specific instances. Note that this looks through all of them. Use it sparingly
		 * NOTE: static methods are invoked using '::' instead of '.'
		 */	
		static def: findByNames(names: Set(String)): Set(LogicalEnumeratedBase) =
			let lnames = names->collect(toLowerCase()) in
			LogicalEnumeratedBase.allInstances()->select(o|lnames->includes(o.name.toLowerCase())) 

 		/**
		 * Find the set of instances rooted at this name. Note that this looks through all of them. Use it sparingly
		 * NOTE: static methods are invoked using '::' instead of '.'
		 */	
		static def: findSetRootedInName(n: String): Set(LogicalEnumeratedBase) =
			findByName(n)->collect(flattenLabels())->asSet()

 		/**
		 * Find the set of instances rooted at this set of names. Note that this looks through all of them. Use it sparingly
		 * NOTE: static methods are invoked using '::' instead of '.'
		 */	
		static def: findSetRootedInNames(names: Set(String)): Set(LogicalEnumeratedBase) =
			findByNames(names)->collect(flattenLabels())->asSet()

	/**
	 * Helper method to walk up the enumeration hierachy and 
	 * find the enum with the name specified - or null if it 
	 * isn't above the starting point.
	 */
--    def: containedIn(name: String): Boolean = 
--    	let container = obj.oclAsType(ecore::EObject).eContainer().oclAsType(LogicalEnumeratedBase) in
-- 			container.name.toLower == name or
-- 			container->containedIn(name)

    /*
     * An LogicalEnumeratedBase's name is not an IDL reserved word.
     */                        
    inv nameIsNotReservedWord:
      not UddlElement::isReservedWord(self.name)
 
  context LogicalEnumerated
 
 		 /**
		  * Find the root
		  */
		 def: root(): LogicalEnumerated =
			self
  
--  	static def: findWithName(name: String): Collection(LogicalEnumerated) =
--  		LogicalEnumerated.allInstances()->select(e : LogicalEnumerated| e.name.toLowerCase() = name.toLowerCase())
--  
--  	static def: findWithRQN(rqn: String): Collection(LogicalEnumerated) =
--  		let qn = rqn->tokenize(".")
    /*
     * Helper method - flattens the hierarchy. Can't just use 'flatten' because it expects a collection only , not objects that include collections
     * as members.
	 *
	 *	NOTE: Should this include 'self' at this level because the enum name is not itself a label? This is different than a LogicalEnumeratedSet, where the 
	 *	name of the set is included. Including it (which we do here) does insure that there is no duplication, which would be confusing
	 * 
	 */
   	 def: flattenLabels(): Collection(LogicalEnumeratedBase) =
   	    self.label->closure(e: LogicalEnumeratedBase | if e.oclIsTypeOf(LogicalEnumeratedSet) then e.oclAsType(LogicalEnumeratedSet).label else Bag{e} endif)
   	    	->including(self.oclAsType(LogicalEnumeratedBase))
   	    	-- While not absolutely required, sorting this makes it easier to identify duplicates
   	    	-- ->sortedBy(e|e.name)
   

	-- If there are duplicates, can use this function to order them - then print out their names
	 def: sortedContents(): Collection(LogicalEnumeratedBase) =
	 	self.label->closure(e: LogicalEnumeratedBase | if e.oclIsTypeOf(LogicalEnumeratedSet) then e.oclAsType(LogicalEnumeratedSet).label else Bag{e} endif)->sortedBy(e|e.name)
	 

     inv enumerationLabelNameUniqueDrillDown('Enumeration labels must be unique within the entire enumeration hierarchy. '+ self.name + ' contains a duplicate. Remove duplicate(s) to continue'):
     	asError(self.flattenLabels()->isUnique(name))
    
      
  context LogicalEnumeratedSet
  /**
   * Helper method that flattens set contents
   */  
   	 def: flattenLabels(): Collection(LogicalEnumeratedBase) =
  	    self.label->closure(e: LogicalEnumeratedBase | if e.oclIsTypeOf(LogicalEnumeratedSet) then e.oclAsType(LogicalEnumeratedSet).label else Bag{e} endif)->including(self.oclAsType(LogicalEnumeratedBase))



--    def: containedIn( obj: ecore::EObject): Boolean = 
--    	let container = obj.oclAsType(ecore::EObject).eContainer().oclAsType(LogicalEnumeratedBase) in
--    	container->closure()->includes(obj)

 
     /*
     * An LogicalEnumeratedSet's name is not an IDL reserved word.
     */                        
    inv nameIsNotReservedWord:
      not UddlElement::isReservedWord(self.name)
   	 	
  context LogicalEnumerationLabel
    /*
     * Helper method - end of recursion 
     */    	 
   	def: flattenLabels(): Bag(LogicalEnumeratedBase) =
   		Bag{self.oclAsType(LogicalEnumeratedBase)}
  
  
 context LogicalComposableElement

	/**
	 * Return a set of all the model types referenced by this element
	 */
    def: referencedModelTypes(): Set(ConceptualComposableElement) =
 		if (self.oclIsKindOf(LogicalMeasurement)) then
			self.oclAsType(LogicalMeasurement).referencedModelTypes()
		else
			self.oclAsType(LogicalEntity).referencedModelTypes()
		endif
    	
	/**
	 * Does this element reference the specified type?
	 */
	def: referencesModelType(o:ConceptualObservable): Boolean = 
		self.referencedModelTypes()->includes(o)


context LogicalMeasurement
	/**
	 * Return a set of all the model types referenced by this element
	 */
    def: referencedModelTypes(): Set(ConceptualComposableElement) =
		self.realizes.referencedModelTypes()
		
		
context LogicalEntity

	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		let myComps = self.composition->collect(type.referencedModelTypes())->flatten()->asSet() in
		let parentTypes = if (self.specializes.oclIsUndefined()) then  Bag {} 
		else if self.specializes.oclIsKindOf(ConceptualAssociation) then
			self.specializes.oclAsType(LogicalAssociation).referencedModelTypes() 
			else self.specializes.referencedModelTypes() 
			endif
		endif in
		myComps->union(parentTypes)->asSet()

	def: matchingObservables(checklist: Set(uddl::ConceptualObservable) ): Set(uddl::ConceptualObservable) = 
		self.referencedModelTypes()->selectByType(uddl::ConceptualObservable)->select(t|checklist->includes(t)) 
			
	/**
	 * oclIsKindOf uses the metamodel. We want to follow the UDDL
	 * specialization hierarchy
	 */		
	def: isTypeOrSpecializationOf(t: LogicalEntity): Boolean =
		self = t or self.specializes.isTypeOrSpecializationOf(t)

context LogicalAssociation

	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		let compTypes = self.oclAsType(LogicalEntity).referencedModelTypes() in
		-- This call will also handle the specialization 
		let assocTypes = self.participant->collect(type.referencedModelTypes())->flatten()->asSet() in
		compTypes->union(assocTypes)

 context LogicalView
	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		if (self.oclIsTypeOf(LogicalQuery)) then
			self.oclAsType(LogicalQuery).referencedModelTypes()
		else 
			self.oclAsType(LogicalCompositeQuery).referencedModelTypes()
		endif

context LogicalQuery
	/**
	 * Return a set of all the model types referenced by this element
	 * TODO: This requires a Java call - which isn't yet available.
	 * In the mean time, some simple string parsing might work in limited cases
	 * This only works on a single entity name - need to split it to get more
	 * Also does not work with aliases
	 */
   def: referencedEntities(): Set(LogicalEntity) =
		let fromNdx = self.specification.toLowerCase().indexOf(' from ') in
		let whereNdx = self.specification.toLowerCase().indexOf(' where ') in
		let joinNdx = self.specification.toLowerCase().indexOf(' join ') in
		let endNdx = if ( joinNdx > 0) then 
						joinNdx 
					 else if (whereNdx > 0) then 
					 		whereNdx 
					 	else 
					 		self.specification->size() 
					 	endif
					 endif in
		let name = self.specification.substring(fromNdx+6,endNdx).trim() in
--		let names = nameraw.tokenize(',') in
--		let entities = LogicalEntity.allInstances()->select(o|names.includes(o.name))->asSet() in
		LogicalEntity.allInstances()->select(o|o.name = name)->asSet()
	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		self.referencedEntities()->collect(referencedModelTypes())->flatten()->asSet()


context LogicalCompositeQuery
	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		self.composition->collect(type.referencedModelTypes())->flatten()->asSet()
  
 endpackage