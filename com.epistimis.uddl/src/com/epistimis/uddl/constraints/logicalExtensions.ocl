/**
 * 
 */
import ecore : 'http://www.eclipse.org/emf/2002/Ecore#/'
import  '../../../../../model/generated/Uddl.ecore'
include 'helpers.ocl'
include 'conceptual.ocl'
include 'conceptualExtensions.ocl'

/**
 * This contains more general capability for the EXTENSIONS at the logical level
 */

package uddl 

  context UddlElement
  
   /**
	 * Declare a helper operation to map an ok/warning verdict to ok/error.
	 */
	def: asError(verdict : Boolean) : Boolean = if verdict then true else null endif

  context LogicalEnumerated
  
--  	static def: findWithName(name: String): Collection(LogicalEnumerated) =
--  		LogicalEnumerated.allInstances()->select(e : LogicalEnumerated| e.name.toLowerCase() = name.toLowerCase())
--  
--  	static def: findWithRQN(rqn: String): Collection(LogicalEnumerated) =
--  		let qn = rqn->tokenize(".")
    /*
     * Helper method - flattens the hierarchy. Can't just use 'flatten' because it expects a collection only , not objects that include collections
     * as members.
	 *
	 *	NOTE: Should this include 'self' at this level because the enum name is not itself a label? This is different than a LogicalEnumeratedSet, where the 
	 *	name of the set is included. Including it (which we do here) does insure that there is no duplication, which would be confusing
	 * 
	 */
   	 def: flattenLabels(): Collection(LogicalEnumeratedBase) =
   	    self.label->closure(e: LogicalEnumeratedBase | if e.oclIsTypeOf(LogicalEnumeratedSet) then e.oclAsType(LogicalEnumeratedSet).label else Bag{e} endif)
   	    	->including(self.oclAsType(LogicalEnumeratedBase))
   	    	-- While not absolutely required, sorting this makes it easier to identify duplicates
   	    	-- ->sortedBy(e|e.name)
   

	-- If there are duplicates, can use this function to order them - then print out their names
	 def: sortedContents(): Collection(LogicalEnumeratedBase) =
	 	self.label->closure(e: LogicalEnumeratedBase | if e.oclIsTypeOf(LogicalEnumeratedSet) then e.oclAsType(LogicalEnumeratedSet).label else Bag{e} endif)->sortedBy(e|e.name)
	 

     inv enumerationLabelNameUniqueDrillDown('Enumeration labels must be unique within the entire enumeration hierarchy. '+ self.name + ' contains a duplicate. Remove duplicate(s) to continue'):
     	asError(self.flattenLabels()->isUnique(name))
    
  context LogicalEnumeratedBase
     /*
     * Helper method that reroutes based on derived type
     */      
    def: flattenLabels(): Collection(LogicalEnumeratedBase) =
      if self.oclIsTypeOf(LogicalEnumeratedSet) then
        self.oclAsType(LogicalEnumeratedSet).flattenLabels()
      else -- 
        self.oclAsType(LogicalEnumerationLabel).flattenLabels()
      endif    	

	/**
	 * Helper method to walk up the enumeration hierachy and 
	 * find the enum with the name specified - or null if it 
	 * isn't above the starting point.
	 */
--    def: containedIn(name: String): Boolean = 
--    	let container = obj.oclAsType(ecore::EObject).eContainer().oclAsType(LogicalEnumeratedBase) in
-- 			container.name.toLower == name or
-- 			container->containedIn(name)

    /*
     * An LogicalEnumeratedBase's name is not an IDL reserved word.
     */                        
    inv nameIsNotReservedWord:
      not UddlElement::isReservedWord(self.name)
      
  context LogicalEnumeratedSet
  /**
   * Helper method that flattens set contents
   */  
   	 def: flattenLabels(): Collection(LogicalEnumeratedBase) =
  	    self.label->closure(e: LogicalEnumeratedBase | if e.oclIsTypeOf(LogicalEnumeratedSet) then e.oclAsType(LogicalEnumeratedSet).label else Bag{e} endif)->including(self.oclAsType(LogicalEnumeratedBase))



--    def: containedIn( obj: ecore::EObject): Boolean = 
--    	let container = obj.oclAsType(ecore::EObject).eContainer().oclAsType(LogicalEnumeratedBase) in
--    	container->closure()->includes(obj)

 
     /*
     * An LogicalEnumeratedSet's name is not an IDL reserved word.
     */                        
    inv nameIsNotReservedWord:
      not UddlElement::isReservedWord(self.name)
   	 	
  context LogicalEnumerationLabel
    /*
     * Helper method - end of recursion 
     */    	 
   	def: flattenLabels(): Bag(LogicalEnumeratedBase) =
   		Bag{self.oclAsType(LogicalEnumeratedBase)}
  
  
 context LogicalComposableElement

	/**
	 * Return a set of all the model types referenced by this element
	 */
    def: referencedModelTypes(): Set(ConceptualComposableElement) =
 		if (self.oclIsKindOf(LogicalMeasurement)) then
			self.oclAsType(LogicalMeasurement).referencedModelTypes()
		else
			self.oclAsType(LogicalEntity).referencedModelTypes()
		endif
    	
	/**
	 * Does this element reference the specified type?
	 */
	def: referencesModelType(o:ConceptualObservable): Boolean = 
		self.referencedModelTypes()->includes(o)


context LogicalMeasurement
	/**
	 * Return a set of all the model types referenced by this element
	 */
    def: referencedModelTypes(): Set(ConceptualComposableElement) =
		self.realizes.referencedModelTypes()
		
		
context LogicalEntity

	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		let myComps = self.composition->collect(type.referencedModelTypes())->flatten()->asSet() in
		let parentTypes = if (self.specializes.oclIsUndefined()) then  Bag {} 
		else if self.specializes.oclIsKindOf(ConceptualAssociation) then
			self.specializes.oclAsType(LogicalAssociation).referencedModelTypes() 
			else self.specializes.referencedModelTypes() 
			endif
		endif in
		myComps->union(parentTypes)->asSet()
			

context LogicalAssociation

	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		let compTypes = self.oclAsType(LogicalEntity).referencedModelTypes() in
		-- This call will also handle the specialization 
		let assocTypes = self.participant->collect(type.referencedModelTypes())->flatten()->asSet() in
		compTypes->union(assocTypes)

 context LogicalView
	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		if (self.oclIsTypeOf(LogicalQuery)) then
			self.oclAsType(LogicalQuery).referencedModelTypes()
		else 
			self.oclAsType(LogicalCompositeQuery).referencedModelTypes()
		endif

context LogicalQuery
	/**
	 * Return a set of all the model types referenced by this element
	 * TODO: This requires a Java call - which isn't yet available.
	 * In the mean time, some simple string parsing might work in limited cases
	 * This only works on a single entity name - need to split it to get more
	 * Also does not work with aliases
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		let fromNdx = self.specification.toLowerCase().indexOf(' from ') in
		let whereNdx = self.specification.toLowerCase().indexOf(' where ') in
		let joinNdx = self.specification.toLowerCase().indexOf(' join ') in
		let endNdx = if ( joinNdx > 0) then 
						joinNdx 
					 else if (whereNdx > 0) then 
					 		whereNdx 
					 	else 
					 		self.specification->size() 
					 	endif
					 endif in
		let name = self.specification.substring(fromNdx+6,endNdx).trim() in
--		let names = nameraw.tokenize(',') in
--		let entities = LogicalEntity.allInstances()->select(o|names.includes(o.name))->asSet() in
		let entities = LogicalEntity.allInstances()->select(o|o.name = name)->asSet() in
		entities->collect(referencedModelTypes())->flatten()->asSet()


context LogicalCompositeQuery
	/**
	 * Return a set of all the model types referenced by this element
	 */
	def: referencedModelTypes(): Set(ConceptualComposableElement) =
		self.composition->collect(type.referencedModelTypes())->flatten()->asSet()
  
 endpackage